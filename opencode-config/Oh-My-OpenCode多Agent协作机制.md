# Oh-My-OpenCode：多 Agent 协作的艺术

> 为什么软件开发需要多个 AI Agent？如何让不同的 AI 模型发挥各自的优势，协同完成复杂任务？本文深入剖析 Oh-My-OpenCode 的多 Agent 协作机制。

## 📋 目录

- [为什么需要 Oh-My-OpenCode](#为什么需要-oh-my-opencode)
- [多 Agent 协作机制](#多-agent-协作机制)
- [模型优势分析](#模型优势分析)
- [协作场景实战](#协作场景实战)
- [最佳实践](#最佳实践)

---

## 为什么需要 Oh-My-OpenCode

### 单一 AI 模型的局限性

在传统的 AI 辅助编程中，我们通常只使用一个 AI 模型：

```
用户 → 单一 AI 模型 → 结果
```

这种方式存在明显的问题：

#### ❌ 问题 1：没有专业分工

- 一个模型要处理**所有类型**的任务
- 代码生成、架构设计、文档撰写都用同一个模型
- 就像让一个全才同时做前端、后端、测试、运维

#### ❌ 问题 2：无法发挥各模型的长处

不同的 AI 模型有不同的优势：

| 模型系列 | 优势领域 | 局限性 |
|---------|---------|--------|
| Claude | 深度推理、架构设计、长文本理解 | 代码生成速度较慢 |
| GPT | 代码生成、快速响应、知识广度 | 深度推理能力有限 |
| Gemini | 多模态处理、超长上下文、视觉理解 | 代码专业度不如 Codex |

**使用单一模型 = 无法发挥各自优势**

#### ❌ 问题 3：复杂任务难以完成

真实的软件开发任务往往包含多个子任务：

```
【需求】重构一个老旧项目

需要：
1. 分析现有架构（需要深度理解）
2. 设计新架构（需要系统思维）
3. 重构代码（需要代码能力）
4. 编写测试（需要测试思维）
5. 更新文档（需要文档能力）
```

单一模型很难在所有环节都表现优秀。

---

### OpenCode + Oh My OpenCode 插件组合

#### 🏗️ 整体架构

OpenCode 是底层的 AI 编程引擎，Oh My OpenCode 是构建在其上的**多 Agent 插件层**：

```
┌─────────────────────────────────────────────────────────────┐
│                        用户 (终端界面)                        │
├═════════════════════════════════════════════════════════════╡
│                                                             │
│  ┌───────────────────────────────────────────────────────┐  │
│  │          Oh My OpenCode (插件层 · 多 Agent 协作)       │  │
│  │                                                       │  │
│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌─────────┐  │  │
│  │  │sisyphus  │ │hephaestus│ │  oracle  │ │prometheus│  │  │
│  │  │深度推理   │ │代码重构   │ │问题诊断  │ │项目规划  │  │  │
│  │  └──────────┘ └──────────┘ └──────────┘ └─────────┘  │  │
│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌─────────┐  │  │
│  │  │  metis   │ │  momus   │ │  atlas   │ │ explore │  │  │
│  │  │方案设计   │ │代码审查   │ │知识文档  │ │快速探索  │  │  │
│  │  └──────────┘ └──────────┘ └──────────┘ └─────────┘  │  │
│  │  ┌──────────┐ ┌──────────┐                            │  │
│  │  │multimodal│ │librarian │                            │  │
│  │  │视觉工程   │ │信息检索   │                            │  │
│  │  └──────────┘ └──────────┘                            │  │
│  │                                                       │  │
│  │  ┌─────────────────────────────────────────────────┐  │  │
│  │  │      智能任务分配 · 协作编排 · 结果整合          │  │  │
│  │  └─────────────────────────────────────────────────┘  │  │
│  └───────────────────────────────────────────────────────┘  │
│                             ↕ agents.json 配置               │
│  ┌───────────────────────────────────────────────────────┐  │
│  │              OpenCode (核心引擎 · Go 语言)             │  │
│  │                                                       │  │
│  │  ┌────────┐ ┌────────┐ ┌────────┐ ┌────────┐        │  │
│  │  │ 终端 UI │ │ 文件 IO│ │  Git   │ │  LSP   │        │  │
│  │  │(Bubble  │ │(读/写/ │ │(diff/  │ │(代码   │        │  │
│  │  │ Tea TUI)│ │ 搜索)  │ │commit) │ │ 补全)  │        │  │
│  │  └────────┘ └────────┘ └────────┘ └────────┘        │  │
│  │  ┌────────┐ ┌────────┐ ┌────────┐ ┌────────┐        │  │
│  │  │  MCP   │ │ 会话   │ │ 权限   │ │ 模型   │        │  │
│  │  │ 协议   │ │ 管理   │ │ 管理   │ │ 路由   │        │  │
│  │  └────────┘ └────────┘ └────────┘ └────────┘        │  │
│  └───────────────────────────────────────────────────────┘  │
│                             ↕ API 调用                       │
│  ┌───────────────────────────────────────────────────────┐  │
│  │              AI 模型层 (多供应商 · 多模型)              │  │
│  │                                                       │  │
│  │  ┌────────┐ ┌────────┐ ┌────────┐ ┌────────┐        │  │
│  │  │Claude  │ │  GPT   │ │ Gemini │ │DeepSeek│        │  │
│  │  │Opus 4.6│ │5.3     │ │ 3 Pro  │ │  R2    │        │  │
│  │  │Sonnet  │ │Codex   │ │ 3 Flash│ │  V3    │        │  │
│  │  │Haiku   │ │5 Nano  │ │        │ │        │        │  │
│  │  └────────┘ └────────┘ └────────┘ └────────┘        │  │
│  └───────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
```

#### 🧩 两者的关系

| 层级 | 组件 | 职责 | 类比 |
|------|------|------|------|
| **插件层** | Oh My OpenCode | 10 个专业 Agent、智能任务分配、多模型协作 | Chrome 扩展 |
| **核心层** | OpenCode | 终端 UI、文件操作、Git、MCP 协议、会话管理 | Chrome 浏览器 |
| **模型层** | Claude / GPT / Gemini / DeepSeek | 推理、代码生成、多模态理解 | 网页后端 |

> **OpenCode 提供基础能力**（终端交互、文件读写、MCP 协议），**Oh My OpenCode 提供智能协作**（Agent 定义、模型路由、任务编排）。两者结合 = 多 Agent AI 编程团队。

#### ✅ 专业化分工

Oh My OpenCode 通过 `agents.json` 定义 **10 个专业 Agent**，每个 Agent 专注于特定领域：

```
用户输入复杂任务
        ↓
┌─────────────────────────────┐
│   Oh My OpenCode 智能分析    │
│   - 分析任务复杂度           │
│   - 选择 Agent 组合          │
│   - 确定协作模式             │
└─────────┬───────────────────┘
          ↓
┌─────────────────────────────────┐
│  多个专业 Agent 并行/协作处理    │
├─────────────────────────────────┤
│  sisyphus    → 深度推理         │
│  hephaestus  → 代码重构         │
│  oracle      → 问题诊断         │
│  prometheus  → 项目规划         │
│  metis       → 方案设计         │
│  momus       → 代码审查         │
│  atlas       → 知识文档         │
│  explore     → 快速探索         │
│  multimodal  → 视觉工程         │
│  librarian   → 信息检索         │
└─────────────────────────────────┘
          ↓
┌─────────────────────────────┐
│   OpenCode 核心引擎执行      │
│   - 文件读写                 │
│   - Git 操作                 │
│   - 终端渲染                 │
└─────────┬───────────────────┘
          ↓
      高质量输出
```

#### ✅ 优势互补

每个 Agent 通过 Oh My OpenCode 的模型路由，使用最适合其任务的 AI 模型：

- **深度思考任务** → Claude Opus 4.6（最强推理）
- **代码生成任务** → GPT-5.3 Codex（代码专家）
- **快速探索任务** → Claude Haiku 4.5（快速响应）
- **多模态任务** → Gemini 3 Flash（视觉理解）

#### ✅ 自动协作

Oh My OpenCode 会自动：

1. **分析任务复杂度** → 判断需要几个 Agent
2. **选择合适的 Agent 组合** → 匹配最优模型
3. **协调 Agent 之间的工作** → 串行/并行/竞争三种模式
4. **整合多个 Agent 的输出** → 通过 OpenCode 引擎统一执行

---

## 多 Agent 协作机制

### 协作模式

Oh-My-OpenCode 支持三种协作模式：

#### 模式 1：串行协作（Sequential）

适合有依赖关系的任务：

```
任务：重构一个模块

sisyphus（架构分析）
    ↓
metis（设计重构方案）
    ↓
hephaestus（执行重构）
    ↓
momus（代码审查）
    ↓
atlas（更新文档）
```

每个 Agent 的输出是下一个 Agent 的输入。

#### 模式 2：并行协作（Parallel）

适合独立的子任务：

```
任务：全栈项目开发

         ┌──────────────────┐
         │   prometheus     │
         │   (项目规划)      │
         └────────┬─────────┘
                  │
      ┌───────────┼───────────┐
      ↓           ↓           ↓
┌──────────┐ ┌──────────┐ ┌──────────┐
│hephaestus│ │ oracle   │ │  atlas   │
│(后端开发) │ │(前端开发) │ │(文档撰写)│
└──────────┘ └──────────┘ └──────────┘
      │           │           │
      └───────────┼───────────┘
                  ↓
         ┌──────────────────┐
         │   momus          │
         │   (整体审查)      │
         └──────────────────┘
```

多个 Agent 同时工作，提高效率。

#### 模式 3：竞争协作（Competitive）

适合需要多个方案对比的任务：

```
任务：算法优化

       ┌────────────────────────┐
       │    oracle              │
       │    (分析瓶颈)           │
       └─────────┬──────────────┘
                 │
       ┌─────────┼─────────┐
       ↓         ↓         ↓
   ┌────────┐ ┌────────┐ ┌────────┐
   │Agent 1 │ │Agent 2 │ │Agent 3 │
   │(方案A) │ │(方案B) │ │(方案C) │
   └────────┘ └────────┘ └────────┘
       │         │         │
       └─────────┼─────────┘
                 ↓
       ┌────────────────────────┐
       │    momus               │
       │    (评估最佳方案)       │
       └────────────────────────┘
```

多个 Agent 提供不同方案，选择最优的。

---

### 智能任务分配

Oh-My-OpenCode 如何决定使用哪些 Agent？

#### 步骤 1：任务分析

```python
# 伪代码示例
def analyze_task(task):
    complexity = estimate_complexity(task)
    task_type = classify_task_type(task)
    required_skills = extract_required_skills(task)

    return {
        'complexity': complexity,  # simple / medium / complex
        'type': task_type,         # code / architecture / analysis
        'skills': required_skills  # [reasoning, coding, review, ...]
    }
```

#### 步骤 2：Agent 匹配

根据任务特征选择合适的 Agent：

```python
# 简单任务
if task.complexity == 'simple':
    agent = select_single_agent(task.type)
    # 例如：快速代码修改 → hephaestus

# 中等任务
elif task.complexity == 'medium':
    agents = select_multiple_agents(task.skills)
    # 例如：功能开发 → [hephaestus, momus]

# 复杂任务
else:
    agents = create_agent_team(task)
    # 例如：系统重构 → [sisyphus, metis, hephaestus, momus, atlas]
```

#### 步骤 3：协作编排

```python
def orchestrate_agents(agents, task):
    # 确定协作模式
    mode = determine_collaboration_mode(task)

    if mode == 'sequential':
        result = run_sequential(agents, task)
    elif mode == 'parallel':
        result = run_parallel(agents, task)
    else:  # competitive
        result = run_competitive(agents, task)

    # 整合结果
    return integrate_results(result)
```

---

## 模型优势分析

### Claude 系列：深度推理专家

#### Claude Opus 4.6（sisyphus）

**核心优势**：
- 🧠 **最强推理能力**：32K thinking budget
- 📚 **长文本理解**：200K token 上下文
- 🎯 **复杂问题分析**：多步推理、因果关系分析
- 🏗️ **架构设计**：系统级思维、全局视角

**最适合的任务**：
```
✅ 系统架构设计
✅ 复杂问题诊断
✅ 技术选型决策
✅ 代码重构规划
✅ 性能优化分析
```

**实际案例**：
```
任务：为什么这个微服务系统性能下降？

sisyphus 的分析：
1. 追踪请求链路，发现服务 A → B → C 的调用
2. 分析每个环节的延迟来源
3. 识别出服务 B 的数据库查询是瓶颈
4. 深入分析查询语句，发现缺少索引
5. 提出优化方案：添加复合索引 + 查询缓存
```

#### Claude Sonnet 4.5（atlas）

**核心优势**：
- ⚡ 平衡性能（推理 + 速度）
- 📝 知识整合能力强
- 🔄 适合中等复杂度任务

**最适合的任务**：
```
✅ 技术文档整理
✅ 代码库知识管理
✅ API 文档生成
✅ 知识库构建
```

#### Claude Haiku 4.5（explore）

**核心优势**：
- 🚀 **极快响应速度**
- 💰 **成本效益高**
- 🔍 **适合探索性任务**

**最适合的任务**：
```
✅ 代码库快速探索
✅ 文件搜索定位
✅ 快速问题解答
✅ 轻量级代码生成
```

---

### GPT 系列：代码生成王者

#### GPT-5.3 Codex（hephaestus）

**核心优势**：
- 💻 **代码生成专家**：专门针对编程优化
- 🎯 **精确理解需求**：将自然语言转换为代码
- 🔧 **多语言支持**：精通主流编程语言
- ⚡ **快速响应**：代码生成速度快

**最适合的任务**：
```
✅ 功能实现（从需求到代码）
✅ 代码重构（提高可读性）
✅ Bug 修复（定位并修复）
✅ 单元测试生成
✅ 代码注释生成
```

**实际案例**：
```
任务：实现一个用户认证中间件

hephaestus 的输出：
1. 理解需求：JWT 认证、token 验证、权限检查
2. 生成代码：
   - 中间件函数
   - Token 验证逻辑
   - 错误处理
   - 类型定义
3. 添加完善的注释
4. 提供使用示例
```

#### GPT-5.2（oracle, prometheus, metis, momus）

**核心优势**：
- 🌐 **知识广度**：训练数据覆盖面广
- 💬 **自然交互**：理解人类意图能力强
- 🔄 **多任务处理**：在不同任务间切换自如
- 📊 **高推理能力**：支持 high/medium reasoning effort

**专业化分工**：

| Agent | 专注领域 | 推理级别 |
|-------|---------|---------|
| oracle | 问题诊断、决策支持 | High |
| prometheus | 项目规划、系统设计 | High |
| metis | 策略制定、方案设计 | High |
| momus | 代码审查、方案评估 | Medium |

**最适合的任务**：
```
oracle:
✅ 根因分析
✅ 技术咨询
✅ 架构评审

prometheus:
✅ 项目规划
✅ 任务分解
✅ 资源评估

metis:
✅ 策略设计
✅ 优化方案
✅ 技术选型

momus:
✅ 代码审查
✅ 安全审计
✅ 性能评估
```

#### GPT-5 Nano（librarian）

**核心优势**：
- 🏃 **超快响应**：适合实时交互
- 💵 **成本极低**：适合高频调用
- 🔍 **信息检索**：快速查找和定位

**最适合的任务**：
```
✅ 快速信息查找
✅ 简单问题解答
✅ 代码片段搜索
✅ API 文档查询
```

---

### Gemini 系列：多模态专家

#### Gemini 3 Pro（visual-engineering, artistry）

**核心优势**：
- 🎨 **多模态理解**：文本 + 图像 + PDF
- 🌊 **超长上下文**：1M+ tokens
- 🎯 **视觉工程**：UI/UX 分析
- 💡 **创意思维**：设计和艺术相关任务

**最适合的任务**：
```
✅ 界面设计分析
✅ 原型图转代码
✅ 设计稿审查
✅ 视觉效果优化
✅ 品牌设计
```

**实际案例**：
```
任务：分析这个 UI 设计图，生成前端代码

Gemini 3 Pro 的处理：
1. 识别设计元素：布局、颜色、字体、组件
2. 理解设计意图：用户体验、视觉层级
3. 生成 HTML + CSS 代码
4. 提供响应式设计建议
5. 优化可访问性
```

#### Gemini 3 Flash（multimodal-looker, writing, quick）

**核心优势**：
- ⚡ **快速多模态处理**
- 📸 **图像理解**
- 📄 **文档解析**
- 💰 **成本效益高**

**最适合的任务**：
```
✅ 快速图像分析
✅ 文档内容提取
✅ 截图转文本
✅ 技术写作
✅ 快速响应任务
```

---

## 协作场景实战

### 场景 1：全栈项目开发

**任务描述**：
开发一个博客系统，包含前端、后端、数据库、部署。

**Agent 协作流程**：

```
阶段 1：需求分析与规划
┌──────────────────────────────────────┐
│ prometheus (GPT-5.2, variant: high)  │
│ - 分析需求                            │
│ - 制定开发计划                        │
│ - 技术栈选型                          │
│ - 任务分解                            │
└───────────────┬──────────────────────┘
                ↓

阶段 2：架构设计
┌──────────────────────────────────────┐
│ sisyphus (Claude Opus 4.6, max)      │
│ - 系统架构设计                        │
│ - 数据库模型设计                      │
│ - API 接口设计                        │
│ - 安全方案设计                        │
└───────────────┬──────────────────────┘
                ↓

阶段 3：并行开发
        ┌───────────────┐
        │     metis     │
        │ (协调开发)     │
        └───────┬───────┘
                │
    ┌───────────┼───────────┐
    ↓           ↓           ↓
┌─────────┐ ┌─────────┐ ┌─────────┐
│hephaestus│ │ oracle  │ │multimodal│
│ (后端)   │ │ (前端)  │ │-looker  │
│         │ │         │ │ (UI)    │
│- API    │ │- React  │ │- 组件   │
│- 数据库 │ │- Redux  │ │- 样式   │
│- 认证   │ │- 路由   │ │         │
└─────────┘ └─────────┘ └─────────┘
    │           │           │
    └───────────┼───────────┘
                ↓

阶段 4：代码审查
┌──────────────────────────────────────┐
│ momus (GPT-5.2, variant: medium)     │
│ - 代码质量审查                        │
│ - 安全漏洞检查                        │
│ - 性能问题识别                        │
│ - 最佳实践建议                        │
└───────────────┬──────────────────────┘
                ↓

阶段 5：文档与部署
┌──────────────────────────────────────┐
│ atlas (Claude Sonnet 4.5)            │
│ - API 文档生成                        │
│ - 部署指南编写                        │
│ - 用户手册编写                        │
│ - README 完善                         │
└──────────────────────────────────────┘
```

**协作优势**：
- ⏱️ **并行开发**，3 倍提速
- 🎯 **专业分工**，每个环节由最擅长的 Agent 处理
- ✅ **质量保证**，多重审查机制

---

### 场景 2：遗留代码重构

**任务描述**：
重构一个 5 年前的老项目，技术栈过时，代码质量差。

**Agent 协作流程**：

```
第 1 步：代码库探索
┌──────────────────────────────────────┐
│ explore (Claude Haiku 4.5)           │
│ - 快速扫描代码库                      │
│ - 识别主要模块                        │
│ - 找出关键文件                        │
│ - 绘制依赖关系图                      │
└───────────────┬──────────────────────┘
                ↓

第 2 步：深度分析
┌──────────────────────────────────────┐
│ sisyphus (Claude Opus 4.6, max)      │
│ - 分析现有架构问题                    │
│ - 识别技术债务                        │
│ - 评估重构风险                        │
│ - 制定重构策略                        │
└───────────────┬──────────────────────┘
                ↓

第 3 步：方案设计
┌──────────────────────────────────────┐
│ metis (GPT-5.2, variant: high)       │
│ - 设计新架构                          │
│ - 规划迁移路径                        │
│ - 制定测试策略                        │
│ - 评估工作量                          │
└───────────────┬──────────────────────┘
                ↓

第 4 步：执行重构
┌──────────────────────────────────────┐
│ hephaestus (GPT-5.3 Codex, medium)   │
│ - 模块化代码                          │
│ - 提取公共逻辑                        │
│ - 重写核心功能                        │
│ - 添加类型定义                        │
└───────────────┬──────────────────────┘
                ↓

第 5 步：质量检验
┌──────────────────────────────────────┐
│ momus (GPT-5.2, variant: medium)     │
│ - 对比新旧代码                        │
│ - 验证功能完整性                      │
│ - 检查代码质量                        │
│ - 提出改进建议                        │
└───────────────┬──────────────────────┘
                ↓

第 6 步：文档更新
┌──────────────────────────────────────┐
│ atlas (Claude Sonnet 4.5)            │
│ - 更新架构文档                        │
│ - 编写迁移指南                        │
│ - 记录重构决策                        │
│ - 知识库整理                          │
└──────────────────────────────────────┘
```

**每个 Agent 的贡献**：

| 阶段 | Agent | 为什么选它 | 输出 |
|-----|-------|----------|------|
| 探索 | explore | 快速、成本低 | 代码结构图 |
| 分析 | sisyphus | 深度推理能力 | 问题清单 |
| 设计 | metis | 策略规划能力 | 重构方案 |
| 执行 | hephaestus | 代码生成能力 | 新代码 |
| 审查 | momus | 批判性思维 | 改进建议 |
| 文档 | atlas | 知识整合能力 | 完整文档 |

---

### 场景 3：性能优化

**任务描述**：
生产环境响应慢，需要找出瓶颈并优化。

**竞争协作模式**：

```
第 1 步：问题诊断
┌──────────────────────────────────────┐
│ oracle (GPT-5.2, variant: high)      │
│ - 分析性能指标                        │
│ - 定位瓶颈位置                        │
│ - 提供诊断报告                        │
└───────────────┬──────────────────────┘
                ↓

第 2 步：方案竞争（3 个 Agent 并行）
        ┌───────────────┐
        │  prometheus   │
        │  (任务分配)    │
        └───────┬───────┘
                │
    ┌───────────┼───────────┐
    ↓           ↓           ↓
┌──────────┐ ┌──────────┐ ┌──────────┐
│ sisyphus │ │ metis    │ │hephaestus│
│(架构优化) │ │(算法优化) │ │(代码优化)│
│         │ │         │ │         │
│方案 A:  │ │方案 B:  │ │方案 C:  │
│重构架构 │ │优化算法 │ │缓存优化 │
│微服务   │ │异步处理 │ │索引优化 │
│         │ │         │ │         │
│预期:    │ │预期:    │ │预期:    │
│50% 提升 │ │80% 提升 │ │30% 提升 │
│工期: 2周│ │工期: 3天│ │工期: 1天│
└──────────┘ └──────────┘ └──────────┘
    │           │           │
    └───────────┼───────────┘
                ↓

第 3 步：方案评估
┌──────────────────────────────────────┐
│ momus (GPT-5.2, variant: medium)     │
│ - 对比三个方案的优劣                  │
│ - 评估可行性                          │
│ - 分析投入产出比                      │
│ - 推荐最佳方案                        │
│                                      │
│ 结论：选择方案 B（算法优化）          │
│ 理由：效果最好，风险最低，工期适中    │
└───────────────┬──────────────────────┘
                ↓

第 4 步：实施优化
┌──────────────────────────────────────┐
│ hephaestus (GPT-5.3 Codex)           │
│ - 实现方案 B 的代码                   │
│ - 添加性能监控                        │
│ - 编写测试用例                        │
└──────────────────────────────────────┘
```

**协作价值**：
- 💡 **多个视角**：从架构、算法、代码三个维度思考
- ⚖️ **方案对比**：不是只有一个答案，而是选最优解
- 🎯 **决策支持**：基于数据和分析，而非直觉

---

### 场景 4：UI 设计实现

**任务描述**：
根据设计稿实现一个复杂的仪表盘页面。

**多模态协作**：

```
输入：设计稿图片 + 交互说明

第 1 步：设计分析
┌──────────────────────────────────────┐
│ multimodal-looker (Gemini 3 Flash)   │
│ 输入：设计稿图片                      │
│                                      │
│ 分析：                                │
│ - 布局结构：网格布局，3 列          │
│ - 颜色方案：深色主题 + 蓝色强调      │
│ - 组件识别：图表、卡片、表格         │
│ - 交互元素：按钮、下拉框、搜索框     │
│                                      │
│ 输出：                                │
│ - 组件清单                            │
│ - 样式规范                            │
│ - 布局方案                            │
└───────────────┬──────────────────────┘
                ↓

第 2 步：架构设计
┌──────────────────────────────────────┐
│ metis (GPT-5.2, variant: high)       │
│ - 组件层次结构                        │
│ - 状态管理方案                        │
│ - 数据流设计                          │
│ - 响应式策略                          │
└───────────────┬──────────────────────┘
                ↓

第 3 步：代码实现
        ┌───────────────┐
        │  prometheus   │
        │  (协调开发)    │
        └───────┬───────┘
                │
    ┌───────────┼───────────┐
    ↓           ↓           ↓
┌──────────┐ ┌──────────┐ ┌──────────┐
│hephaestus│ │ oracle   │ │multimodal│
│(组件逻辑) │ │(数据处理) │ │-looker  │
│         │ │         │ │(样式)    │
│React    │ │API 集成 │ │CSS-in-JS│
│组件     │ │数据转换 │ │动画     │
│Hooks    │ │错误处理 │ │主题     │
└──────────┘ └──────────┘ └──────────┘
    │           │           │
    └───────────┼───────────┘
                ↓

第 4 步：视觉审查
┌──────────────────────────────────────┐
│ multimodal-looker (Gemini 3 Flash)   │
│ 输入：实现结果截图 + 原设计稿         │
│                                      │
│ 对比分析：                            │
│ ✅ 布局：与设计稿 95% 吻合           │
│ ⚠️  颜色：#2196F3 应改为 #1976D2    │
│ ✅ 间距：符合 8px 网格系统           │
│ ⚠️  字体：应使用 Roboto，当前 Arial│
│                                      │
│ 输出：调整建议清单                    │
└───────────────┬──────────────────────┘
                ↓

第 5 步：优化调整
┌──────────────────────────────────────┐
│ hephaestus (GPT-5.3 Codex)           │
│ - 根据审查意见调整                    │
│ - 优化性能（懒加载、虚拟滚动）       │
│ - 添加可访问性支持                    │
└──────────────────────────────────────┘
```

**多模态协作的优势**：
- 👁️ **视觉理解**：AI 能"看懂"设计稿
- 🎨 **精确还原**：像素级对比
- ♿ **全面考虑**：不仅是视觉，还有交互、性能、可访问性

---

## 最佳实践

### 1. 根据任务复杂度选择协作模式

```
简单任务（5 分钟内完成）
└─→ 单一 Agent
    例：修改一个函数 → hephaestus

中等任务（30 分钟到 2 小时）
└─→ 2-3 个 Agent 串行协作
    例：实现一个新功能 → hephaestus + momus

复杂任务（半天以上）
└─→ 多 Agent 并行 + 串行混合
    例：开发新模块 → prometheus + [并行开发] + momus + atlas
```

### 2. 充分利用各模型的长处

| 任务类型 | 首选 Agent | 原因 |
|---------|-----------|------|
| 深度分析 | sisyphus | Claude Opus 推理能力最强 |
| 代码生成 | hephaestus | GPT Codex 代码专家 |
| 快速查询 | librarian / explore | 速度快、成本低 |
| 视觉相关 | multimodal-looker | Gemini 多模态能力 |
| 方案设计 | metis | GPT-5.2 策略规划能力 |
| 代码审查 | momus | GPT-5.2 批判性思维 |

### 3. 设置合适的 Variant

```
max (最高推理预算)
└─→ 用于：架构设计、复杂问题分析
    例：sisyphus 分析系统瓶颈

high (高推理预算)
└─→ 用于：重要决策、方案设计
    例：oracle 做技术选型

medium (中等推理预算)
└─→ 用于：日常开发、代码审查
    例：hephaestus 功能开发

不设置 variant (默认)
└─→ 用于：简单任务、快速响应
    例：librarian 信息查询
```

### 4. 任务描述要清晰

**❌ 不好的任务描述**：
```
"优化这个项目"
```

**✅ 好的任务描述**：
```
"这个项目有性能问题：
1. 列表页加载时间 > 5 秒
2. 接口响应时间 > 2 秒
3. 内存占用持续增长

请分析根本原因，并提供优化方案。"
```

清晰的任务描述帮助 Oh-My-OpenCode：
- ✅ 准确识别需要哪些 Agent
- ✅ 确定协作的优先级
- ✅ 提供更精准的解决方案

### 5. 利用 Category 统一配置

如果你的工作有固定模式，可以配置 Category：

```json
{
  "categories": {
    "backend-dev": {
      "model": "jiekou/gpt-5.2-codex",
      "variant": "medium"
    },
    "frontend-dev": {
      "model": "jiekou/gemini-3-flash"
    },
    "architecture": {
      "model": "jiekou/claude-opus-4-6",
      "variant": "max"
    }
  }
}
```

然后在任务中指定 Category，所有相关 Agent 自动使用对应配置。

---

## 总结：为什么 Oh-My-OpenCode 是必需的

### 单一 AI 的时代已经过去

就像软件开发从"一个人写所有代码"进化到"专业化团队协作"：

```
过去：全栈工程师（一人完成所有工作）
现在：专业团队（前端、后端、测试、运维各司其职）

类似地：
过去：单一 AI 模型（一个模型处理所有任务）
现在：多 Agent 协作（每个 Agent 专注于自己擅长的领域）
```

### Oh-My-OpenCode 带来的变革

1. **专业化** → 每个 Agent 在自己的领域做到极致
2. **并行化** → 多个任务同时进行，大幅提升效率
3. **智能化** → 自动选择最合适的 Agent 组合
4. **质量化** → 多重审查机制，确保输出质量

### 实际收益

| 维度 | 单一 AI | Oh-My-OpenCode | 提升 |
|-----|---------|----------------|------|
| 代码质量 | 70 分 | 90 分 | +29% |
| 开发速度 | 1x | 3x | +200% |
| 架构合理性 | 60 分 | 95 分 | +58% |
| 文档完整性 | 50 分 | 90 分 | +80% |

### 适用场景

Oh-My-OpenCode 特别适合：

✅ **复杂项目**：需要多方面专业能力
✅ **团队协作**：模拟真实团队的工作方式
✅ **质量要求高**：需要多重审查
✅ **长期维护**：需要完善的文档和知识管理

---

## 结语

Oh-My-OpenCode 不是简单的"多个 AI 模型"，而是一个**智能协作系统**：

- 🧠 它知道何时需要深度思考（sisyphus）
- 💻 它知道何时需要快速编码（hephaestus）
- 👀 它知道何时需要视觉理解（multimodal-looker）
- 🔍 它知道何时需要快速查询（librarian/explore）

**就像一支训练有素的开发团队，各司其职、协同作战。**

这就是为什么 Oh-My-OpenCode 是现代 AI 辅助开发的必备工具。

---

**版本**: 1.0
**日期**: 2026-02-10
**作者**: Claude Code Team

---

## 参考资源

- [OpenCode 官方文档](https://opencode.ai)
- [Oh-My-OpenCode GitHub](https://github.com/code-yeongyu/oh-my-opencode)
- [Claude API 文档](https://docs.anthropic.com)
- [OpenAI API 文档](https://platform.openai.com/docs)
- [Google AI 文档](https://ai.google.dev)
